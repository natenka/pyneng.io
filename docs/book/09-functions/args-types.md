# Типи аргументів функції

Під час виклику функції аргументи можна передати двома способами:

* як позиційні - передаються в тому ж порядку, в якому вони визначені при
  створенні функції. Тобто порядок, у якому передаються аргументи, визначає,
  яке значення отримає кожен параметр.
* як іменовані - передаються із зазначенням імені аргументу та його значенням.
  У такому разі аргументи можуть бути вказані в будь-якому порядку, тому що їх
  ім'я вказується явно.

![function](https://pyneng.io/assets/images/09_function_args.png)

Позиційні та іменовані аргументи можуть використовуватись одночасно при виклику
функції. При цьому спочатку мають йти позиційні аргументи, а потім - іменовані.

Різні способи передачі аргументів з прикладу функції check_passwd

```python
def check_passwd(username, password):
    if len(password) < 8:
        print("Пароль надто короткий")
        return False
    elif username in password:
        print("Пароль містить ім'я користувача")
        return False
    else:
        print(f"Пароль для користувача {username} встановлено")
        return True
```

## Позиційні аргументи

Позиційні аргументи під час виклику функції треба передати у правильному
порядку.

```python
In [2]: check_passwd("nata", "12345")
Пароль надто короткий
Out[2]: False

In [3]: check_passwd("nata", "12345lsdkjflskfdjsnata")
Пароль містить ім'я користувача
Out[3]: False

In [4]: check_passwd("nata", "12345lsdkjflskfdjs")
Пароль для користувача nata встановлено
Out[4]: True
```

## Іменовані аргументи

Іменовані аргументи:

* передаються із зазначенням імені аргументу
* за рахунок цього вони можуть передаватись у будь-якому порядку

Якщо передати обидва аргументи як іменовані, можна передавати їх у будь-якому
порядку:

```python
In [9]: check_passwd(password="12345", username="nata", min_length=4)
Пароль для користувача nata встановлено
Out[9]: True
```

!!! warning

    Зверніть увагу, що завжди спочатку повинні йти позиційні аргументи, потім іменовані.

Якщо зробити навпаки, виникне помилка:

```python
In [10]: check_passwd(password="12345", username="nata", 4)
  File "<ipython-input-10-7e8246b6b402>", line 1
    check_passwd(password="12345", username="nata", 4)
                                                   ^
SyntaxError: positional argument follows keyword argument
```


Але в такій комбінації можна:

```python
In [11]: check_passwd("nata", "12345", min_length=3)
Пароль для користувача nata встановлено
Out[11]: True
```

У реальному житті часто набагато зрозуміліше і зручніше вказувати параметри
зі значеннями True/False або числові значення як іменований аргумент.
Якщо задати хороше ім'я параметра, то по його імені відразу буде зрозуміло, що
саме він робить.

Наприклад, можна додати параметр, який контролюватиме, виконувати перевірку
наявності імені користувача в паролі чи ні:

```python
def check_passwd(username, password, min_length=8, check_username=True):
    if len(password) < min_length:
        print("Пароль надто короткий")
        return False
    elif check_username and username in password:
        print("Пароль містить ім'я користувача")
        return False
    else:
        print(f"Пароль для користувача {username} встановлено")
        return True
```


За замовчуванням параметр дорівнює True, а значить перевірку виконувати треба:

```python
In [14]: check_passwd("nata", "12345nata", min_length=3)
Пароль містить ім'я користувача
Out[14]: False

In [15]: check_passwd("nata", "12345nata", min_length=3, check_username=True)
Пароль містить ім'я користувача
Out[15]: False
```

Якщо встановити значення False, перевірка не буде виконана:

```python
In [16]: check_passwd("nata", "12345nata", min_length=3, check_username=False)
Пароль для користувача nata встановлено
Out[16]: True
```
