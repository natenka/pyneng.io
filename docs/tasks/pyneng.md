# Утиліта pyneng

## Де робити завдання

Завдання треба виконувати у підготовлених файлах.

Наприклад, у розділі 04_data_structures є завдання 4.3. Щоб виконати його,
потрібно відкрити файл exercises/04_data_structures/task_4_3.py і виконувати
завдання прямо в цьому файлі після опису завдання.


## Скрипт pyneng


### Встановлення скрипту [pyneng](https://github.com/natenka/pyneng-cli)

```
pip install pyneng-cli
```

Це встановить модуль і дозволить викликати його в каталогах завдань за словом pyneng.

Етапи роботи із завданнями:

1. Виконання завдань
2. Перевірте, що завдання відпрацьовує як потрібно ``python task_4_2.py`` або запуск скрипта в редакторі/IDE
3. Перевірка завдань тестами ``pyneng 1-5``
4. Якщо тести проходять, дивимося варіанти розв'язання ``pyneng 1-5 -a``


> Другий крок дуже важливий, тому що на цьому етапі набагато простіше знайти
> помилки у синтаксисі та подібні проблеми з роботою скрипту, ніж при запуску
> коду через тест на 3 етапі.


## Перевірка завдань тестами

Після виконання завдання його треба перевірити за допомогою тестів. Для запуску
тестів потрібно викликати pyneng в каталозі завдань. Наприклад, якщо ви робите
4 розділ завдань, треба перебувати в каталозі exercises/04_data_structures/ і
запустити pyneng одним із способів, залежно від того, які завдання на
перевіряти.


[Приклади виводу тестів з поясненнями](/tasks/pyneng-output)

Запуск перевірки всіх завдань поточного розділу:

```
pyneng
```

Запуск тестів для завдання 4.1:

```
pyneng 1
```

Запуск тестів для завдань 4.1, 4.2, 4.3:

```
pyneng 1-3
```

Якщо є завдання з літерами, наприклад, у 7 розділі, можна запускати так, щоб
запустити перевірку для завдань 7.2a, 7.2b (треба перебувати в каталозі
07_files):

```
pyneng 2a-b
```

або так, щоб запустити всі завдання 7.2x з літерами та без:

```
pyneng 2*
```


## Отримання відповідей

Цей функціонал працює тільки за наявності [git cli](https://git-scm.com/book/uk/v2/%D0%92%D1%81%D1%82%D1%83%D0%BF-%D0%86%D0%BD%D1%81%D1%82%D0%B0%D0%BB%D1%8F%D1%86%D1%96%D1%8F-Git).
{: .notice--danger}

Якщо завдання проходять тести, можна переглянути варіанти вирішення завдань.

Для цього до попередніх варіантів команди слід додати -a. Такий виклик означає
запустити тести для завдань 1 та 2 та скопіювати відповіді, якщо тести пройшли:

```
pyneng 1-2 -a
```

Тоді для вказаних завдань запустяться тести і для тих завдань, які пройшли
тести, скопіюються відповіді у файли answer_task_x.py в поточному каталозі.


## Завантажити всі зміни в поточному каталозі на github, без прив'язки до того чи проходять тести

```
pyneng --save-all
```

Виконує команди

```
git add .
git commit -m "Все изменения сохранены"
git push origin main
```

## Оновлення розділів


Цей функціонал працює тільки за наявності [git cli](https://git-scm.com/book/uk/v2/%D0%92%D1%81%D1%82%D1%83%D0%BF-%D0%86%D0%BD%D1%81%D1%82%D0%B0%D0%BB%D1%8F%D1%86%D1%96%D1%8F-Git).
{: .notice--danger}

У pyneng є два варіанти оновлення: оновлювати розділи або конкретні
завдання/тести. При оновленні розділу каталог розділу видаляється і копіюється
нова версія. Це підходить тільки для тих розділів, які ви ще не виконували.
Якщо потрібно оновити конкретне завдання, то краще використовувати оновлення
конкретних завдань (розглядається далі).

Перед будь-яким варіантом поновлення бажано зберегти всі локальні зміни на
github!

Для оновлення розділів, треба перейти до каталогу exercises/ та дати команду:

```
pyneng --update-chapters 12-25
```

В цьому випадку оновляться розділи 12-25. Також можна вказувати один розділ:

```
pyneng --update-chapters 11
```

Або кілька через кому

```
pyneng --update-chapters 12,15,17
```

## Оновлення завдань та тестів

У завданнях і тестах зустрічаються неточності і щоб їх можна було виправити,
pyneng додано опцію ``--update``.


Загальна логіка:

* завдання та тести копіюються з [репозиторію](https://github.com/natenka/pynenguk-tasks)
* копіює весь файл завдання, не тільки опис, тому файл перепишеться
* перед виконанням –update, краще зберегти всі зміни на github


Як працює ``--update``:

* якщо у репозиторії є незбережені зміни, утиліта пропонує їх зберегти (зробить ``git add.``, ``git commit``, ``git push``)
* якщо незбережених змін немає, копіюються зазначені завдання та тести
* утиліта пропонує зберегти зміни та показує які файли змінені, але не які саме зроблені зміни
* можна відмовитись зберігати зміни та подивитися зміни git diff


#### Варіанти виклику

Оновити всі завдання та тести розділу:

```
pyneng --update
```

Оновити всі тести розділу (тільки тести, не завдання):

```
pyneng --update --test-only
```

Оновити завдання 1,2 та відповідні тести розділу

```
pyneng 1,2 --update
```

Якщо жодних оновлень немає, буде такий вивід

```
$ pyneng --update
#################### git pull
Already up-to-date.

Updated tasks and tests copied
Tasks and tests are already the latest version
Aborted!
```

Будь-коли можна перервати оновлення Ctrl-C.

Приклад виведення з незбереженими змінами та наявністю оновлень
```
pyneng --update
THIS WILL OVERWRITE THE CONTENT OF UNSAVED FILES!
There are unsaved changes in the current directory! Do you want to save them? [y/n]:y
##################### git add .
#################### git commit -m "Save changes before updating tasks"
[main 0e8c1cb] Saving changes before updating tasks
 1 file changed, 1 insertion(+)

##################### git push origin main
To git@github.com:pyneng/my-tasks.git
   fa338c3..0e8c1cb main -> main

All changes in the current directory are saved. Let's start updating...
##################### git pull
Already up-to-date.


Updated tasks and tests copied
The following files have been updated:
##################### git diff --stat
 exercises/04_data_structures/task_4_0.py | 0
 exercises/04_data_structures/task_4_1.py | one -
 exercises/04_data_structures/task_4_3.py | 3---
 3 files changed, 0 insertions(+), 4 deletions(-)


This is a short diff, if you want to see all the differences in detail, press n and issue the git diff command.
You can also undo your changes with git checkout -- file (or git restore file) if you want.

Save changes and add to github? [y/n]:n
tasks and tests have been successfully updated
Aborted!
```

## Вивід pyneng

### Warning

Наприкінці виведення тесту часто написано "1 warning". Це можна ігнорувати,
попередження переважно пов'язані з роботою якихось модулів і приховані щоб не
відволікати від завдань.

### Тести пройшли успішно

![passed](https://pyneng.io/assets/images/pyneng1.png)

### Тести не пройшли

Коли які-то тести не пройшли, у виведенні показуються відмінності між тим, як
повинен виглядати вивід і який вивід був отриманий. Перевірка
правильності виведення в тесті перевіряється за допомогою виразу `assert`.
Два найбільш поширених варіанти (98% тестів):

```python
assert correct_return_value == return_value
assert correct_output in return_output
```

#### assert x == y

У більшості завдань перевіряється рівність двох значень:

```python
assert correct_return_value == return_value
```

В цьому випадку тест виводить вивід `LHS vs RHS` і показує різницю між
значенням ліворуч (correct_return_value) та праворуч (return_value). Тести
навмисно написані так, щоб ліворуч від знаку рівності було вірне значення, а
праворуч значення отримане із завдання. В цьому випадку зеленим відображається
правильне значення, а червоним значення отримане із завдання.

У цьому завданні було виведено рядок `AAAA:BBBB:CCCC`, а потрібно було вивести `AAAA.BBBB.CCCC`.

![passed](https://pyneng.io/assets/images/pyneng2.png)

У завданні потрібно отримати список із вланами, де кожен влан окремий елемент
списку, а отриманий рядок, у якому написані всі влани:

![passed](https://pyneng.io/assets/images/pyneng3.png)


Вивід правильний, окрім зайвого пробілу між FastEthernet та номером інтерфейсу:

![passed](https://pyneng.io/assets/images/pyneng5.png)


#### assert x in y

Вираз `assert x in y` перевіряє, чи знаходиться потрібний вивід в отриманому результаті завдання.
Наприклад, в тесті це може виглядати так:

```python
assert correct_stdout in out.strip()
```

В даному випадку це перевірка того, що на екран було виведене повідомлення "no
such parameter", а замість цього було виведене значення None:

![passed](https://pyneng.io/assets/images/pyneng6.png)

Тут повідомлення в завданні мало бути "too low", а виведене "too high". Для цього завдання це впливає на два тести.
В першому, тест не знайшов текст "low" у виведенні:

![passed](https://pyneng.io/assets/images/pyneng7.png)

У другому тесті, повідомлення "too low" мало бути виведене 5 разів, а виведене
0 (тут випадок коли зелене не означає правильне значення):

![passed](https://pyneng.io/assets/images/pyneng8.png)

### Неправильний тип даних

Крім іншого в результаті, може також відрізнятися тип даних. Наприклад, за
завданням потрібно отримати список, а отриманий рядок.  В цьому випадку легше зрозуміти
проблему за повідомленням:

![passed](https://pyneng.io/assets/images/pyneng4.png)
